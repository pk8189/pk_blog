import styles from './document.module.css'

<div className={styles["Welcome"]}>

# Building a python crypto trading bot for the Gemini Exchange: Part 1

This post is part 1 of a 4 part series about building/using a custom framework made to evaluate and deploy crypto trading stratagies.

Part 1: Designing a python package and CLI that can interact with the gemini exchange from scratch with Poetry.

Part 2: Creating a development user friendly framework for writing custom trading stratagies.

Part 3: Data, model evaluation, and bias. Featuring hints into a strategy backed by a genetic algorithm.

Part 4: Deploying your strategy to production with Docker.


## Designing a python package that can interact with the gemini exchange from scratch with Poetry.

This post is suited for pythonistas interested in building their own python packages. If you have an idea 
for a package that you want to share with the world or simply want to improve your app's backend by splitting out 
some generalizable functionality into a seperate package this post is for you.


The process outlined in this article will result in a package with the following features:
1. A command line interface that will be available to users upon install (pip install). 
2. Commands for interacting with the gemini public and private API.
3. A secure way for users to store their Gemini credentials while using the package.

## Initializing the package with Conda and Poetry.

[Conda](https://docs.conda.io/en/latest/) is an open source package and virtual environment management system. 
A virtual environment is a tool that helps to maintain separate the 
dependencies required by different projects by creating isolated python virtual environments for each dependency. 
After installing conda, we initalize our virtual environmemt with:
```bash
conda create -n gemini_bot python=3.8
conda activate gemini_bot
```

[Poetry](https://python-poetry.org) provides open source packaging and dependency management. When the `gemini_bot` 
virtual environment is active, poetry will detect that conda is being used as the virtual environment manager.
The pyproject.toml file is the centerpiece of poetry. In the toml we can specify any package attribute we may need.
To create a pyproject.toml interactively, use
```bash
poetry init
```
After following the description/naming steps interactively, we install the dependencies we need for this project with:
```
poetry install
poetry add gemini_python
poetry add python-dotenv
poetry add pylint --dev 
```
Pylint isn't necessary for production, so we add the --dev flag.
When installing from the .toml for production, we would use 
```
poetry install --no-dev
```

## Building the command line interface

Poetry scripts are another useful feature available within poetry.
With scripts, we can name a command that calls a script.
```toml
[tool.poetry.scripts]
gemini_bot = "gemini_bot.cli.__main__:main"
```
When a user has our package installed and types `gemini_bot`, scripts calls
the main() function in the root of our CLI living in `gemini_bot/cli/__main__.py`

This is structure of our __main__.py
```python
from dotenv import load_dotenv

from gemini_bot.cli.commands import commands

def main() -> None:
    instantiated_commands = [C() for C in commands]
    parser = create_parser(commands)
    args, _ = parser.parse_known_args()
    cs = {command.name: command for command in instantiated_commands}
    command = cs.get(args.command, None)
    if not command:
        return parser.print_help()
    run(command, args)

def run(command: Any, args: Namespace) -> Callable:
    env_path = Path.cwd() / ".env"
    load_dotenv(dotenv_path=env_path)
    try:
        return command.run(args)
    except SystemError as e:
        print(e)

def create_parser(subcommands: list) -> ArgumentParser:
    """Adds predict arguments to parser.

    :return: Namespace arguments
    """
    parser = ArgumentParser(prog="gemini_bot")
    subparsers = parser.add_subparsers(dest="command")
    for subcommand in subcommands:
        subparser = subparsers.add_parser(subcommand.name)
        subcommand().add_arguments(subparser)
    return parser
```

With argparse we can build a parser with a series of subparsers. `gemini_bot` is our parser, and each specified command 
in gemini_bot/cli/commands/__init__.py is a subparser. Each command contains a name variable, an `add_arguments()` function and a `handle()` function.
`name` specifies the name of the subparser, `add_arguments(parser)` allows us to build the structure of the args for the command. `handle(args)` 
is given the args and controls the main actions performed by the command. Below is the beginning of `gemini_bot/cli/commands/public.py` which contains commands
dealing with the gemini public api. 

```
from argparse import ArgumentParser, Namespace

from gemini_bot.cli.base_command import BaseCommand

class Symbols(BaseCommand):

    name = "symbols"

    def handle(self, args: Namespace):
        print(self.client.symbols())

    def add_arguments(self, parser: ArgumentParser) -> None:
        pass

class GetTradeHistory(BaseCommand):

    name = "get_trade_history"

    def handle(self, args: Namespace):
        print(self.client.get_trade_history(args.symbol, args.since))

    def add_arguments(self, parser: ArgumentParser) -> None:
        parser.add_argument(
            "-s", "--symbol", required=True, help="Symbol to query"
        )
        parser.add_argument(
            "-d", "--since", help="Date to get trade history since"
        )
```

Here is the output of the symbols command which queries the gemini public api /symbols endpoint:
```
$ gemini_bot symbols
['btcusd', 'ethbtc', 'ethusd', 'bchusd', 'bchbtc', 'bcheth', 'ltcusd', 'ltcbtc', 'ltceth', 'ltcbch', 'zecusd', 'zecbtc', 'zeceth', 'zecbch', 'zecltc']
```



## Using python-dotenv for a safe experience with api keys

Storing and using sensative api keys like the gemini api key and the gemini secret is a serious matter.
If a gemini_bot user were to push these keys to an open repository, anyone could obtain control of the associated account.
Gemini bot uses environment variables to get API_KEY and API_SECRET, which give the user access to the private API.
The user can either export the variables in the shell `export API_KEY=xxxxxx` or use a .env file. By default the package
looks in $PWD/.env if it exists, to find the environment variables.  With `python-dotenv` we can set this default .env path in one line:
```
    env_path = Path.cwd() / ".env"
    load_dotenv(dotenv_path=env_path)
```
We call this in the root of the CLI, and any subsequent code that may be called has access to the variable like any other environment variable.
```
from os import getenv
api_key = getenv("API_KEY")
```

## Publishing your package

If you haven't done so already, go register for an account at [pypi](https://pypi.org/account/register/)
```
poetry build
poetry publish
```
Will build a wheel and publish your to the open source world!

</div>