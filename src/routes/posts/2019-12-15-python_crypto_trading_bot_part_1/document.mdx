import styles from './document.module.css'

<div className={styles["Welcome"]}>

# Building a python crypto trading bot for the Gemini Exchange: Part 1

This post is part 1 of a 4 part series about building/using a custom framework made to evaluate and deploy 
one or many crypto trading stratagies.

Part 1: Designing a python package that can interact with the gemini exchange from scratch with Poetry.

Part 2: Creating a dev user friendly framework for writing custom trading stratagies.

Part 3: Data, model evaluation, and bias. Featuring hints into a strategy backed by a genetic algorithm.

Part 4: Deploying your strategy to production with Docker.


## Designing a python package that can interact with the gemini exchange from scratch with Poetry.

This post is suited for pythonistas interested in building their own python packages.
Have an idea for a package that you want to share with the world? Want to improve your app's backend by splitting out 
some generalizable functionality into a seperate package? If you answered yes to either of those questions keep on reading.


The package that we will build in this article will contain the following features:
1. A command line interface that will be available to users upon install. 
2. Commands for interacting with the gemini public and private API.
3. A secure way for users to store their Gemini credentials while using the package.

## Initializing the package with Conda and Poetry.

[conda](https://docs.conda.io/en/latest/) is an open source package and virtual environment management system.
We will leverage conda as our virtual environment.  A virtual environment is a tool that helps to keep dependencies 
required by different projects separate by creating isolated python virtual environments for them. After installing
conda, we initalize our virtual environmemt with:
```bash
conda create -n gemini_bot python=3.8
conda activate gemini_bot
```

[Poetry](https://python-poetry.org) gives us an open source packaging and dependency management. If the `gemini_bot` 
virtual environment is active, poetry will detect that conda is being used as the virtual environment manager.
The pyproject.toml file is the centerpiece of poetry. It let's us specify any package attribute we need.
To create a pyproject.toml interactively, use
```bash
poetry init
```
After following the description/naming steps interactively, we install the dependencies we need for this project with:
```
poetry install
poetry add gemini_python
poetry add python-dotenv
poetry add pylint --dev 
```
Pylint isn't necessary for production, so we add the --dev flag.
If we were installing from the .toml on production, we would use 
```
poetry install --no-dev
```

## Building the command line interface

Another useful feature we get from poetry is poetry scripts.
With scripts, we can name a command that calls a script.
```toml
[tool.poetry.scripts]
gemini_bot = "gemini_bot.cli.__main__:main"
```
When a user has our package installed and types `gemini_bot`, scripts calls
the main() function in the root of our CLI living in `gemini_bot/cli/__main__.py`

This is structure of our __main__.py
```python
from dotenv import load_dotenv

from gemini_bot.cli.commands import commands

def main() -> None:
    instantiated_commands = [C() for C in commands]
    parser = create_parser(commands)
    args, _ = parser.parse_known_args()
    cs = {command.name: command for command in instantiated_commands}
    command = cs.get(args.command, None)
    if not command:
        return parser.print_help()
    run(command, args)

def run(command: Any, args: Namespace) -> Callable:
    env_path = Path.cwd() / ".env"
    load_dotenv(dotenv_path=env_path)
    try:
        return command.run(args)
    except SystemError as e:
        print(e)

def create_parser(subcommands: list) -> ArgumentParser:
    """Adds predict arguments to parser.

    :return: Namespace arguments
    """
    parser = ArgumentParser(prog="gemini_bot")
    subparsers = parser.add_subparsers(dest="command")
    for subcommand in subcommands:
        subparser = subparsers.add_parser(subcommand.name)
        subcommand().add_arguments(subparser)
    return parser
```

Argparse let's us build a parser with a series of subparsers. `gemini_bot` is our parser, and each specified command 
in gemini_bot/cli/commands/__init__.py becomes a subparser. Each command contains a name variable, an add_arguments() function and a handle() function.
`name` specifies the name of the subparser, `add_arguments(parser)` let's us build the structure of the args for the command. `handle(args)` 
is given the args and controls the main actions performed by the command. Below is the beginning of `gemini_bot/cli/commands/public.py` which contains commands
dealing with the gemini public api. 

```
from argparse import ArgumentParser, Namespace

from gemini_bot.cli.base_command import BaseCommand

class Symbols(BaseCommand):

    name = "symbols"

    def handle(self, args: Namespace):
        print(self.client.symbols())

    def add_arguments(self, parser: ArgumentParser) -> None:
        pass

class GetTradeHistory(BaseCommand):

    name = "get_trade_history"

    def handle(self, args: Namespace):
        print(self.client.get_trade_history(args.symbol, args.since))

    def add_arguments(self, parser: ArgumentParser) -> None:
        parser.add_argument(
            "-s", "--symbol", required=True, help="Symbol to query"
        )
        parser.add_argument(
            "-d", "--since", help="Date to get trade history since"
        )
```

Here is the output of the symbols command which queries the gemini public api /symbols endpoint:
```
$ gemini_bot symbols
['btcusd', 'ethbtc', 'ethusd', 'bchusd', 'bchbtc', 'bcheth', 'ltcusd', 'ltcbtc', 'ltceth', 'ltcbch', 'zecusd', 'zecbtc', 'zeceth', 'zecbch', 'zecltc']
```



## Using python-dotenv for a safe experience with api keys

Storing and using sensative api keys like the gemini api key and the gemini secret is a serious matter.
If a user of gemini_bot pushed these keys to an open repository, anyone could obtain control of the associated account.
Gemini bot uses environment variables to get API_KEY and API_SECRET, which give the user access to the private API.
The user can either export the variables in the shell `export API_KEY=xxxxxx` or use a .env file. By default the package
looks in $PWD/.env if it exists, to find the environment variables.  Python-dotenv let's us sets this default .env path in one line:
```
    env_path = Path.cwd() / ".env"
    load_dotenv(dotenv_path=env_path)
```
We call this in the root of the CLI, and any subsequent code that may be called has access to the variable like any other environment variable.
```
from os import getenv
api_key = getenv("API_KEY")
```

## Publishing your package

If you haven't done so already, go register for an account at [pypi](https://pypi.org/account/register/)
Read the poetry documentation to properly use
```
poetry publish
```
Which will build and publish your to the open source world!


</div>